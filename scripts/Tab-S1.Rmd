---
title: "Tab. S1: ANONA modeling of the effect of plant explanatory variables on microbial alpha diversity measures of the bacterial and fungal communities."
author: "Jessica Finck"
date: "2025-05-12"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
set.seed(123)
```

This script analyses the soil microbial communities alpha diversity via ANOVA linear mixed modeling using the `lme4` package.

### Pre-processing: Preparing the `phyloseq` objects from raw data

For this analysis we use `phyloseq` objects which we created from our ASV and taxa tables, and metadata.

First, we imported our data into R.

```{r import, tidy=TRUE, message=FALSE, warning=FALSE, results='hide', echo=FALSE}
library(readxl) # import xlsx files
library(dplyr)  # data wrangling
library(ape)    # import nwk files

# bacteria
otu_bac <- read_excel("masterfile_bac.xlsx", sheet = "asv_table") %>% as.data.frame()
tax_bac <- read_excel("masterfile_bac.xlsx", sheet = "tax_table") %>% as.data.frame()
data_bac <- read_excel("masterfile_bac.xlsx", sheet = "metadata_all") %>% as.data.frame()
tree_bac <- ape::read.tree("tree_dada2_bac.nwk")

# fungi
otu_fun <- read_excel("masterfile_fun.xlsx", sheet = "asv_table") %>% as.data.frame()
tax_fun <- read_excel("masterfile_fun.xlsx", sheet = "tax_table") %>% as.data.frame()
data_fun <- read_excel("masterfile_fun.xlsx", sheet = "metadata_all") %>% as.data.frame()
tree_fun <- ape::read.tree("tree_dada2_fun.nwk")
```

Then, we formatted the variable classes.

```{r format, tidy=TRUE, message=FALSE, warning=FALSE, results='hide', echo=FALSE}
# bacteria 
data_bac = data_bac %>% mutate(leg_num = leg)  
data_bac$leg_num = gsub('yes', '1', data_bac$leg_num)
data_bac$leg_num = gsub('no', '0', data_bac$leg_num)
data_bac$leg_num <- as.numeric(data_bac$leg_num)

data_bac = data_bac %>% mutate(gra_num = gra)  
data_bac$gra_num = gsub('yes', '1', data_bac$gra_num)
data_bac$gra_num = gsub('no', '0', data_bac$gra_num)
data_bac$gra_num <- as.numeric(data_bac$gra_num)

data_bac = data_bac %>% mutate(monocult_num = monocult)  
data_bac$monocult_num = gsub('yes', '1', data_bac$monocult_num)
data_bac$monocult_num = gsub('no', '0', data_bac$monocult_num)
data_bac$monocult_num <- as.numeric(data_bac$monocult_num)

data_bac = data_bac %>% mutate(plot_num = plot) 
data_bac$plot_num <- as.numeric(data_bac$plot_num)

data_bac$psr <- as.numeric(data_bac$psr)
data_bac$div_level <- as.factor(data_bac$div_level)
data_bac$plot <- as.factor(data_bac$plot)
data_bac$the <- as.factor(data_bac$the)
data_bac$she <- as.factor(data_bac$she)
data_bac$leg <- as.factor(data_bac$leg)
data_bac$gra <- as.factor(data_bac$gra)

# fungi
data_fun = data_fun %>% mutate(leg_num = leg)  
data_fun$leg_num = gsub('yes', '1', data_fun$leg_num)
data_fun$leg_num = gsub('no', '0', data_fun$leg_num)
data_fun$leg_num <- as.numeric(data_fun$leg_num)

data_fun = data_fun %>% mutate(gra_num = gra)  
data_fun$gra_num = gsub('yes', '1', data_fun$gra_num)
data_fun$gra_num = gsub('no', '0', data_fun$gra_num)
data_fun$gra_num <- as.numeric(data_fun$gra_num)

data_fun = data_fun %>% mutate(monocult_num = monocult)  
data_fun$monocult_num = gsub('yes', '1', data_fun$monocult_num)
data_fun$monocult_num = gsub('no', '0', data_fun$monocult_num)
data_fun$monocult_num <- as.numeric(data_fun$monocult_num)

data_fun = data_fun %>% mutate(plot_num = plot) 
data_fun$plot_num <- as.numeric(data_fun$plot_num)

data_fun$psr <- as.numeric(data_fun$psr)
data_fun$div_level <- as.factor(data_fun$div_level)
data_fun$plot <- as.factor(data_fun$plot)
data_fun$the <- as.factor(data_fun$the)
data_fun$she <- as.factor(data_fun$she)
data_fun$leg <- as.factor(data_fun$leg)
data_fun$gra <- as.factor(data_fun$gra)
```

Followed by adjusting the taxa names and defining the row names.

```{r names, tidy=TRUE, message=FALSE, warning=FALSE, results='hide', echo=FALSE}
# bacteria
tax_bac$Kingdom = gsub("d__","",as.character(tax_bac$Kingdom))
tax_bac$Phylum = gsub("p__","",as.character(tax_bac$Phylum))
tax_bac$Class = gsub("c__","",as.character(tax_bac$Class))
tax_bac$Order = gsub("o__","",as.character(tax_bac$Order))
tax_bac$Family = gsub("f__","",as.character(tax_bac$Family))
tax_bac$Genus = gsub("g__","",as.character(tax_bac$Genus))
tax_bac$Species = gsub("s__","",as.character(tax_bac$Species))

otu_bac <- otu_bac %>% tibble::column_to_rownames("asv")
tax_bac <- tax_bac %>% tibble::column_to_rownames("asv")
data_bac <- data_bac %>% tibble::column_to_rownames("sID")

# fungi
tax_fun$Kingdom = gsub("k__","",as.character(tax_fun$Kingdom))
tax_fun$Phylum = gsub("p__","",as.character(tax_fun$Phylum))
tax_fun$Class = gsub("c__","",as.character(tax_fun$Class))
tax_fun$Order = gsub("o__","",as.character(tax_fun$Order))
tax_fun$Family = gsub("f__","",as.character(tax_fun$Family))
tax_fun$Genus = gsub("g__","",as.character(tax_fun$Genus))
tax_fun$Species = gsub("s__","",as.character(tax_fun$Species))

otu_fun <- otu_fun %>% tibble::column_to_rownames("asv")
tax_fun <- tax_fun %>% tibble::column_to_rownames("asv")
data_fun <- data_fun %>% tibble::column_to_rownames("sID")
```

And finally writing the `phyloseq` objects.

```{r ps, tidy=TRUE, message=FALSE, warning=FALSE, results='hide', echo=FALSE}
library(phyloseq)

# bacteria 
otu_bac <- as.matrix(otu_bac)
tax_bac <- as.matrix(tax_bac)

OTU_B = phyloseq::otu_table(otu_bac, taxa_are_rows = T)
TAX_B = phyloseq::tax_table(tax_bac)
samples_B = phyloseq::sample_data(data_bac)
ps.bac <- phyloseq::phyloseq(OTU_B, TAX_B, samples_B)
tree_B = phyloseq::phy_tree(tree_bac)
ps.bac <- phyloseq::phyloseq(OTU_B, TAX_B, samples_B, tree_B)

# fungi
otu_fun <- as.matrix(otu_fun)
tax_fun <- as.matrix(tax_fun)

OTU_F = phyloseq::otu_table(otu_fun, taxa_are_rows = T)
TAX_F = phyloseq::tax_table(tax_fun)
samples_F = phyloseq::sample_data(data_fun)
ps.fun <- phyloseq::phyloseq(OTU_F, TAX_F, samples_F)
tree_F = phyloseq::phy_tree(tree_fun)
ps.fun <- phyloseq::phyloseq(OTU_F, TAX_F, samples_F, tree_F)
```

After writing the phyloseq objects based on the raw counts, we then cleaned up the data using the `microeco` package (i.e., to tidy the taxonomy and filter out chloroplasts and non-bacterial, non-archaeal and non-fungal sequences).

```{r tidy, tidy=TRUE, message=FALSE, warning=FALSE, results='hide', echo=FALSE}
library(microeco)
library(file2meco)

# convert to microeco (meco) object
meco.fun = phyloseq2meco(ps.fun)
meco.bac = phyloseq2meco(ps.bac)

# tidy taxonomy 
meco.bac$tax_table %>% 
  base::subset(Kingdom == "k__Archaea" | Kingdom == "k__Bacteria")
meco.bac$filter_pollution(taxa = c("mitochondria", "chloroplast"))
meco.bac$tidy_dataset()                                                         

meco.fun$tax_table %>% 
  base::subset(Kingdom == "k__Fungi")
meco.fun$filter_pollution(taxa = c("mitochondria", "chloroplast"))
meco.fun$tidy_dataset()

# convert back to phyloseq (ps) object
ps.meco.bac = meco2phyloseq(meco.bac)
ps.meco.fun = meco2phyloseq(meco.fun)
```

Lastly, we TSS-transformed, and CLR-normalized the tidied `phyloseq` object to use for follow-up analyses:

```{r normalize, tidy=TRUE, message=FALSE, warning=FALSE, results='hide', echo=FALSE}
library(microbiomeMarker) # TSS normalization
library(microbiome)       # CLR transformation
library(dplyr)            # data wrangling

ps.bac.tss = ps.meco.bac %>% microbiomeMarker::normalize(method = "TSS")
ps.fun.tss = ps.meco.fun %>% microbiomeMarker::normalize(method = "TSS")
ps.bac.norm = ps.meco.bac %>% microbiomeMarker::normalize(method = "TSS") %>% microbiome::transform('clr')
ps.fun.norm = ps.meco.fun %>% microbiomeMarker::normalize(method = "TSS") %>% microbiome::transform('clr')
```

### **1. Linear mixed effect modeling using `stats::aov`**

Model specifics:

-   fixed terms: block, lg_psr, fgr_sown, monocult, has_gra, has_leg

-   interactions: lg_psr \* fgr_sown

-   model is fitted sequentially

```{r extract, tidy=TRUE, message=FALSE, warning=FALSE, results='hide'}
# extract data
data.div.bac = as(sample_data(ps.bac.norm), "data.frame")
data.div.fun = as(sample_data(ps.fun.norm), "data.frame")
```

Create linear models for each alpha diversity measure, and sequentially fit the fixed terms, with block (here: 'plot') as the first effect to access residual variation caused by plant explanatory variables (plant diversity, functional group richness and identity).

Since we don't know the relationship type of plant diversity with the microbial communities, we formulate 3 different models for each alpha diversity measure, and then use the AIC via the `stats::AIC()` function to inspect which model has the best fit. We test the following models:

-   PSR raw values (1, 2, 4, 8 ,16) \> assumes linear relationship

-   log-linearized PSR \> assumes stronger relationship in the beginning with saturation at higher levels

-   PSR as a factor \> assumes non-linear and non-saturated relationship where differences between diversity levels are more important than following a gradient

```{r models1, tidy=TRUE, message=FALSE, warning=FALSE}
library(stats)

## Richness models 1-3 (PSR fitted 1st)
model_ric.B1 = stats::aov(data.div.bac$richness ~ plot + lg_psr *fgr_sown + leg + gra, data = data.div.bac)
model_ric.B2 = stats::aov(data.div.bac$richness ~ plot + psr *fgr_sown + leg + gra, data = data.div.bac)
model_ric.B3 = stats::aov(data.div.bac$richness ~ plot + as.factor(psr) * fgr_sown + leg + gra, data = data.div.bac)

model_ric.F1 = stats::aov(data.div.fun$richness ~ plot + lg_psr *fgr_sown + leg + gra, data = data.div.fun)
model_ric.F2 = stats::aov(data.div.fun$richness ~ plot + psr *fgr_sown + leg + gra, data = data.div.fun)
model_ric.F3 = stats::aov(data.div.fun$richness ~ plot + as.factor(psr) *fgr_sown + leg + gra, data = data.div.fun)

stats::AIC(model_ric.B1,model_ric.B2,model_ric.B3)
stats::AIC(model_ric.F1,model_ric.F2,model_ric.F3)

## Effective Richness models 1-3 (PSR fitted 1st)
model_eff.B1 = stats::aov(data.div.bac$eff_richness ~ plot + lg_psr *fgr_sown + leg + gra, data = data.div.bac)
model_eff.B2 = stats::aov(data.div.bac$eff_richness ~ plot + psr *fgr_sown + leg + gra, data = data.div.bac)
model_eff.B3 = stats::aov(data.div.bac$eff_richness ~ plot + as.factor(psr) *fgr_sown + leg + gra, data = data.div.bac)

model_eff.F1 = stats::aov(data.div.fun$eff_richness ~ plot + lg_psr *fgr_sown + leg + gra, data = data.div.fun)
model_eff.F2 = stats::aov(data.div.fun$eff_richness ~ plot + psr *fgr_sown + leg + gra, data = data.div.fun)
model_eff.F3 = stats::aov(data.div.fun$eff_richness ~ plot + as.factor(psr) *fgr_sown + leg + gra, data = data.div.fun)

stats::AIC(model_eff.B1,model_eff.B2,model_eff.B3)
stats::AIC(model_eff.F1,model_eff.F2,model_eff.F3)

## Evenness models 1-3 (PSR fitted 1st)
model_eve.B1 = stats::aov(data.div.bac$evenness ~ plot + lg_psr *fgr_sown + leg + gra, data = data.div.bac)
model_eve.B2 = stats::aov(data.div.bac$evenness ~ plot + psr *fgr_sown + leg + gra, data = data.div.bac)
model_eve.B3 = stats::aov(data.div.bac$evenness ~ plot + as.factor(psr) *fgr_sown + leg + gra, data = data.div.bac)

model_eve.F1 = stats::aov(data.div.fun$evenness ~ plot + lg_psr *fgr_sown + leg + gra, data = data.div.fun)
model_eve.F2 = stats::aov(data.div.fun$evenness ~ plot + psr *fgr_sown + leg + gra, data = data.div.fun)
model_eve.F3 = stats::aov(data.div.fun$evenness ~ plot + as.factor(psr) *fgr_sown + leg + gra, data = data.div.fun)

stats::AIC(model_eve.B1,model_eve.B2,model_eve.B3)
stats::AIC(model_eve.F1,model_eve.F2,model_eve.F3)
```

Now that we have decided on which models have the best fit, we use the selected model to run all parameters with a uniform model design, fitting `lg_psr` and `fgr_sown` interchangeably to investigate their individual effects when fitted before or after:

```{r models2, tidy=TRUE, message=FALSE, warning=FALSE, results='hide'}
library(stats)

## Richness model (PSR fitted 1st)
model_ric.B1 = stats::aov(data.div.bac$richness ~ plot + psr *fgr_sown + leg + gra, data = data.div.bac)

model_ric.F1 = stats::aov(data.div.fun$richness ~ plot + psr *fgr_sown + leg + gra, data = data.div.fun)

## Richness model (PSR fitted 2nd)
model_ric.B2 = stats::aov(data.div.bac$richness ~ plot + fgr_sown*psr + leg + gra, data = data.div.bac)

model_ric.F2 = stats::aov(data.div.fun$richness ~ plot + fgr_sown*psr + leg + gra, data = data.div.fun)

## Effective Richness model (PSR fitted 1st)
model_eff.B1 = stats::aov(data.div.bac$eff_richness ~ plot + psr *fgr_sown + leg + gra, data = data.div.bac)

model_eff.F1 = stats::aov(data.div.fun$eff_richness ~ plot + psr *fgr_sown + leg + gra, data = data.div.fun)

## Effective Richness model (PSR fitted 2nd)
model_eff.B2 = stats::aov(data.div.bac$eff_richness ~ plot + fgr_sown*psr + leg + gra, data = data.div.bac)

model_eff.F2 = stats::aov(data.div.fun$eff_richness ~ plot + fgr_sown*psr + leg + gra, data = data.div.fun)

## Evenness model (PSR fitted 1st)
model_eve.B1 = stats::aov(data.div.bac$evenness ~ plot + psr *fgr_sown + leg + gra, data = data.div.bac)

model_eve.F1 = stats::aov(data.div.fun$evenness ~ plot + psr *fgr_sown + leg + gra, data = data.div.fun)

## Evenness model (PSR fitted 2nd)
model_eve.B2 = stats::aov(data.div.bac$evenness ~ plot + fgr_sown*psr + leg + gra, data = data.div.bac)

model_eve.F2 = stats::aov(data.div.fun$evenness ~ plot + fgr_sown*psr + leg + gra, data = data.div.fun)
```

ANOVA and summary statistics:

```{r stats, tidy=TRUE, message=FALSE, warning=FALSE}
# ANOVA models for bacteria
anova(model_ric.B1) # PSR fitted 1st
anova(model_ric.B2) # PSR fitted 2nd
anova(model_eff.B1) # PSR fitted 1st
anova(model_eff.B2) # PSR fitted 2nd
anova(model_eve.B1) # PSR fitted 1st
anova(model_eve.B2) # PSR fitted 2nd

# ANOVA models for fungi
anova(model_ric.F1) # PSR fitted 1st
anova(model_ric.F2) # PSR fitted 2nd 
anova(model_eff.F1) # PSR fitted 1st
anova(model_eff.F2) # PSR fitted 2nd
anova(model_eve.F1) # PSR fitted 1st
anova(model_eve.F2) # PSR fitted 2nd
```

**1.3 Calculate %Sum of Squares, and create summary table**

Our goal is to create a table with all F and *p*-values, already modified to show 3 digits after comma, along with the %SS. As we have many models, we write a function to simplify the process, which calculates the %SS, rounds our F, *p*, and %SS values to be uniform, and binds all them together based on domain of life for easier export.

Write the function:

```{r functionSS, tidy=TRUE, message=FALSE, warning=FALSE, results='hide'}
get_model_stats <- function(model) {
  aov_tab <- anova(model)
  # Extract all SS including residuals for %SS calculation
  SS <- aov_tab$"Sum Sq"
  total_SS <- sum(SS, na.rm = TRUE)
  # Now remove residuals for the table
  aov_tab <- aov_tab[!rownames(aov_tab) %in% c("Residual", "Total"), ]
  Fval <- aov_tab$"F value"
  pval <- aov_tab$"Pr(>F)"
  perc_SS <- round((aov_tab$"Sum Sq" / total_SS) * 100, 3)
  data.frame(
    Term = rownames(aov_tab),
    F_value = round(Fval, 3),
    p_value = round(pval, 3),
    Percent_SS = perc_SS,
    row.names = NULL
  )
}
```

Now we apply our function to our models:

```{r functionUSE, tidy=TRUE, message=FALSE, warning=FALSE, results='hide'}
## Summarize models in lists
models.B1 <- list(Richness = model_ric.B1, Eff_Richness = model_eff.B1, Evenness = model_eve.B1)
models.B2 <- list(Richness = model_ric.B2, Eff_Richness = model_eff.B2, Evenness = model_eve.B2)
models.F1 <- list(Richness = model_ric.F1, Eff_Richness = model_eff.F1, Evenness = model_eve.F1)
models.F2 <- list(Richness = model_ric.F2, Eff_Richness = model_eff.F2, Evenness = model_eve.F2)

## Apply function
library(dplyr)
library(tidyr)

results_list.B1 <- lapply(models.B1, get_model_stats)
results_list.B2 <- lapply(models.B2, get_model_stats)
results_list.F1 <- lapply(models.F1, get_model_stats)
results_list.F2 <- lapply(models.F2, get_model_stats)

names(results_list.B1) <- names(models.B1)
names(results_list.B2) <- names(models.B2)
names(results_list.F1) <- names(models.F1)
names(results_list.F2) <- names(models.F2)
```

And combine the output into fewer summary tables:

```{r functionSUMMARY, tidy=TRUE, message=FALSE, warning=FALSE}
## Combine all results
results_table.B1 <- bind_rows(results_list.B1, .id = "Model")
results_table.B2 <- bind_rows(results_list.B2, .id = "Model")
results_table.F1 <- bind_rows(results_list.F1, .id = "Model")
results_table.F2 <- bind_rows(results_list.F2, .id = "Model")

## Exports as table
wide_table.B1 <- results_table.B1 %>% pivot_wider(
  names_from = Model, values_from = c(F_value, p_value, Percent_SS), names_glue = "{.value}_{Model}")
wide_table.B2 <- results_table.B2 %>% pivot_wider(
  names_from = Model, values_from = c(F_value, p_value, Percent_SS), names_glue = "{.value}_{Model}")
wide_table.F1 <- results_table.F1 %>% pivot_wider(
  names_from = Model, values_from = c(F_value, p_value, Percent_SS), names_glue = "{.value}_{Model}")
wide_table.F2 <- results_table.F2 %>% pivot_wider(
  names_from = Model, values_from = c(F_value, p_value, Percent_SS), names_glue = "{.value}_{Model}")

## Reorder columns to match final format
wide_table.B1 <- wide_table.B1 %>% select(Term, 
                                          F_value_Richness, p_value_Richness,
                                          Percent_SS_Richness, 
                                          F_value_Eff_Richness, p_value_Eff_Richness, Percent_SS_Eff_Richness, 
                                          F_value_Evenness, p_value_Evenness, Percent_SS_Evenness)
wide_table.B2 <- wide_table.B2 %>% select(Term, 
                                          F_value_Richness, p_value_Richness, Percent_SS_Richness, 
                                          F_value_Eff_Richness, p_value_Eff_Richness, Percent_SS_Eff_Richness, 
                                          F_value_Evenness, p_value_Evenness, Percent_SS_Evenness)
wide_table.F1 <- wide_table.F1 %>% select(Term, 
                                          F_value_Richness, p_value_Richness, Percent_SS_Richness, 
                                          F_value_Eff_Richness, p_value_Eff_Richness, Percent_SS_Eff_Richness, 
                                          F_value_Evenness, p_value_Evenness, Percent_SS_Evenness)
wide_table.F2 <- wide_table.F2 %>% select(Term, 
                                          F_value_Richness, p_value_Richness, Percent_SS_Richness, 
                                          F_value_Eff_Richness, p_value_Eff_Richness, Percent_SS_Eff_Richness, 
                                          F_value_Evenness, p_value_Evenness, Percent_SS_Evenness)

## View output
View(wide_table.B1)
View(wide_table.B2)
View(wide_table.F1)
View(wide_table.F2)
```

Lastly, we created an illustration for Figure 2 panel B in Inkscape, visually summarizing the output (%SS, *p*) of our PERMANOVA tests.
