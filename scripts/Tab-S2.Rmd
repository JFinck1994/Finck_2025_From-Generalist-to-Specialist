---
title: "Tab. S2: Permutational multivariate analysis of variance (PERMANOVA) of dissimilarities, based on UniFrac distances of the (A) bacterial and (B) fungal community compositions."
author: "Jessica Finck"
date: "2025-05-12"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
set.seed(123)
```

This script analyses the soil microbial communities beta diversity using PERMANOVA to assess which environmental parameters significantly affect soil microbial community structure.

### Pre-processing: Preparing the `phyloseq` objects from raw data

For this analysis we use `phyloseq` objects which we created from our ASV and taxa tables, and metadata.

First, we imported our data into R.

```{r import, tidy=TRUE, message=FALSE, warning=FALSE, results='hide', echo=FALSE}
library(readxl) # import xlsx files
library(dplyr)  # data wrangling
library(ape)    # import nwk files

# bacteria
otu_bac <- read_excel("masterfile_bac.xlsx", sheet = "asv_table") %>% as.data.frame()
tax_bac <- read_excel("masterfile_bac.xlsx", sheet = "tax_table") %>% as.data.frame()
data_bac <- read_excel("masterfile_bac.xlsx", sheet = "metadata_all") %>% as.data.frame()
tree_bac <- ape::read.tree("tree_dada2_bac.nwk")

# fungi
otu_fun <- read_excel("masterfile_fun.xlsx", sheet = "asv_table") %>% as.data.frame()
tax_fun <- read_excel("masterfile_fun.xlsx", sheet = "tax_table") %>% as.data.frame()
data_fun <- read_excel("masterfile_fun.xlsx", sheet = "metadata_all") %>% as.data.frame()
tree_fun <- ape::read.tree("tree_dada2_fun.nwk")
```

Then, we formatted the variable classes.

```{r format, tidy=TRUE, message=FALSE, warning=FALSE, results='hide', echo=FALSE}
# bacteria 
data_bac = data_bac %>% mutate(leg_num = leg)  
data_bac$leg_num = gsub('yes', '1', data_bac$leg_num)
data_bac$leg_num = gsub('no', '0', data_bac$leg_num)
data_bac$leg_num <- as.numeric(data_bac$leg_num)

data_bac = data_bac %>% mutate(gra_num = gra)  
data_bac$gra_num = gsub('yes', '1', data_bac$gra_num)
data_bac$gra_num = gsub('no', '0', data_bac$gra_num)
data_bac$gra_num <- as.numeric(data_bac$gra_num)

data_bac = data_bac %>% mutate(monocult_num = monocult)  
data_bac$monocult_num = gsub('yes', '1', data_bac$monocult_num)
data_bac$monocult_num = gsub('no', '0', data_bac$monocult_num)
data_bac$monocult_num <- as.numeric(data_bac$monocult_num)

data_bac = data_bac %>% mutate(plot_num = plot) 
data_bac$plot_num <- as.numeric(data_bac$plot_num)

data_bac$psr <- as.numeric(data_bac$psr)
data_bac$div_level <- as.factor(data_bac$div_level)
data_bac$plot <- as.factor(data_bac$plot)
data_bac$the <- as.factor(data_bac$the)
data_bac$she <- as.factor(data_bac$she)
data_bac$leg <- as.factor(data_bac$leg)
data_bac$gra <- as.factor(data_bac$gra)

# fungi
data_fun = data_fun %>% mutate(leg_num = leg)  
data_fun$leg_num = gsub('yes', '1', data_fun$leg_num)
data_fun$leg_num = gsub('no', '0', data_fun$leg_num)
data_fun$leg_num <- as.numeric(data_fun$leg_num)

data_fun = data_fun %>% mutate(gra_num = gra)  
data_fun$gra_num = gsub('yes', '1', data_fun$gra_num)
data_fun$gra_num = gsub('no', '0', data_fun$gra_num)
data_fun$gra_num <- as.numeric(data_fun$gra_num)

data_fun = data_fun %>% mutate(monocult_num = monocult)  
data_fun$monocult_num = gsub('yes', '1', data_fun$monocult_num)
data_fun$monocult_num = gsub('no', '0', data_fun$monocult_num)
data_fun$monocult_num <- as.numeric(data_fun$monocult_num)

data_fun = data_fun %>% mutate(plot_num = plot) 
data_fun$plot_num <- as.numeric(data_fun$plot_num)

data_fun$psr <- as.numeric(data_fun$psr)
data_fun$div_level <- as.factor(data_fun$div_level)
data_fun$plot <- as.factor(data_fun$plot)
data_fun$the <- as.factor(data_fun$the)
data_fun$she <- as.factor(data_fun$she)
data_fun$leg <- as.factor(data_fun$leg)
data_fun$gra <- as.factor(data_fun$gra)
```

Followed by adjusting the taxa names and defining the row names.

```{r names, tidy=TRUE, message=FALSE, warning=FALSE, results='hide', echo=FALSE}
# bacteria
tax_bac$Kingdom = gsub("d__","",as.character(tax_bac$Kingdom))
tax_bac$Phylum = gsub("p__","",as.character(tax_bac$Phylum))
tax_bac$Class = gsub("c__","",as.character(tax_bac$Class))
tax_bac$Order = gsub("o__","",as.character(tax_bac$Order))
tax_bac$Family = gsub("f__","",as.character(tax_bac$Family))
tax_bac$Genus = gsub("g__","",as.character(tax_bac$Genus))
tax_bac$Species = gsub("s__","",as.character(tax_bac$Species))

otu_bac <- otu_bac %>% tibble::column_to_rownames("asv")
tax_bac <- tax_bac %>% tibble::column_to_rownames("asv")
data_bac <- data_bac %>% tibble::column_to_rownames("sID")

# fungi
tax_fun$Kingdom = gsub("k__","",as.character(tax_fun$Kingdom))
tax_fun$Phylum = gsub("p__","",as.character(tax_fun$Phylum))
tax_fun$Class = gsub("c__","",as.character(tax_fun$Class))
tax_fun$Order = gsub("o__","",as.character(tax_fun$Order))
tax_fun$Family = gsub("f__","",as.character(tax_fun$Family))
tax_fun$Genus = gsub("g__","",as.character(tax_fun$Genus))
tax_fun$Species = gsub("s__","",as.character(tax_fun$Species))

otu_fun <- otu_fun %>% tibble::column_to_rownames("asv")
tax_fun <- tax_fun %>% tibble::column_to_rownames("asv")
data_fun <- data_fun %>% tibble::column_to_rownames("sID")
```

And finally writing the `phyloseq` objects.

```{r ps, tidy=TRUE, message=FALSE, warning=FALSE, results='hide', echo=FALSE}
library(phyloseq)

# bacteria 
otu_bac <- as.matrix(otu_bac)
tax_bac <- as.matrix(tax_bac)

OTU_B = phyloseq::otu_table(otu_bac, taxa_are_rows = T)
TAX_B = phyloseq::tax_table(tax_bac)
samples_B = phyloseq::sample_data(data_bac)
ps.bac <- phyloseq::phyloseq(OTU_B, TAX_B, samples_B)
tree_B = phyloseq::phy_tree(tree_bac)
ps.bac <- phyloseq::phyloseq(OTU_B, TAX_B, samples_B, tree_B)

# fungi
otu_fun <- as.matrix(otu_fun)
tax_fun <- as.matrix(tax_fun)

OTU_F = phyloseq::otu_table(otu_fun, taxa_are_rows = T)
TAX_F = phyloseq::tax_table(tax_fun)
samples_F = phyloseq::sample_data(data_fun)
ps.fun <- phyloseq::phyloseq(OTU_F, TAX_F, samples_F)
tree_F = phyloseq::phy_tree(tree_fun)
ps.fun <- phyloseq::phyloseq(OTU_F, TAX_F, samples_F, tree_F)
```

After writing the phyloseq objects based on the raw counts, we then cleaned up the data using the `microeco` package (i.e., to tidy the taxonomy and filter out chloroplasts and non-bacterial, non-archaeal and non-fungal sequences).

```{r tidy, tidy=TRUE, message=FALSE, warning=FALSE, results='hide', echo=FALSE}
library(microeco)
library(file2meco)

# convert to microeco (meco) object
meco.fun = phyloseq2meco(ps.fun)
meco.bac = phyloseq2meco(ps.bac)

# tidy taxonomy 
meco.bac$tax_table %>% 
  base::subset(Kingdom == "k__Archaea" | Kingdom == "k__Bacteria")
meco.bac$filter_pollution(taxa = c("mitochondria", "chloroplast"))
meco.bac$tidy_dataset()                                                         

meco.fun$tax_table %>% 
  base::subset(Kingdom == "k__Fungi")
meco.fun$filter_pollution(taxa = c("mitochondria", "chloroplast"))
meco.fun$tidy_dataset()

# convert back to phyloseq (ps) object
ps.meco.bac = meco2phyloseq(meco.bac)
ps.meco.fun = meco2phyloseq(meco.fun)
```

Lastly, we TSS-transformed, and CLR-normalized the tidied `phyloseq` object to use for follow-up analyses:

```{r normalize, tidy=TRUE, message=FALSE, warning=FALSE, results='hide', echo=FALSE}
library(microbiomeMarker) # TSS normalization
library(microbiome)       # CLR transformation
library(dplyr)            # data wrangling

ps.bac.tss = ps.meco.bac %>% microbiomeMarker::normalize(method = "TSS")
ps.fun.tss = ps.meco.fun %>% microbiomeMarker::normalize(method = "TSS")
ps.bac.norm = ps.meco.bac %>% microbiomeMarker::normalize(method = "TSS") %>% microbiome::transform('clr')
ps.fun.norm = ps.meco.fun %>% microbiomeMarker::normalize(method = "TSS") %>% microbiome::transform('clr')
```

### 1. Permutational Multivariate Analysis of Variance (PERMANOVA)

PERMANOVA can be performed with different packages (i.e. `microeco` or `vegan`). However, as `vegan` was the first package to offer PERMANOVA calculations, and we are distrustful of packages which further automate processes, we decided against using `microeco`, first and foremost as `microeco` offers less transparency into how calculations are made. Also, the results from `vegan` and `microeco` differed, making us distrustful of using the latter.

**1.1 Calculate distance**

As distance calculations don't work well with negative values, we did not perform calculations with the CLR-transformed values like we did for the RDA, but used the TSS-transformed values (`ps.bac` and `ps.fun`) for statistical testing instead. From the 3 well-known distances matrices, we decided on unweighted UniFrac, as we were more interested in the overall composition of communities and turnover of microbes, rather than abundance patterns which were anyhow affected by the underlying block.

```{r distance, tidy=TRUE, message=FALSE, warning=FALSE, results='hide', fig.show='hide'}
# extract ASV data from ps object
library(dplyr)
data.bac1 <- data.frame(sample_data(ps.bac.tss))
data.fun1 <- data.frame(sample_data(ps.fun.tss))
otu.bac.tss = ps.bac.tss %>% phyloseq::otu_table() %>% t() %>% as.data.frame()
otu.fun.tss = ps.fun.tss %>% phyloseq::otu_table() %>% t() %>% as.data.frame()

# calc distance 
library(phyloseq)
#?phyloseq::distance

unif_dist.ps.bac <- phyloseq::distance(ps.bac.tss, method = "unifrac")
unif_dist.ps.fun <- phyloseq::distance(ps.fun.tss, method = "unifrac")
```

**1.2 Running the PERMANOVA using `vegan`**

We used the `adonis()` function to assess the effect of our predictor variables (i.e. PSR, FG richness, FG identity) on our soil microbial communities, while accounting for for the 'block' by sequentially fitting all fixed terms – with 999 permutations – as proposed by Schmidt et al. (2021).

```{r permanova, tidy=TRUE, message=FALSE, warning=FALSE}
# PERMANOVA bacteria 
vegan::adonis2(unif_dist.ps.bac ~ plot + psr*fgr_sown + leg + gra, data = data.bac1, permutations = 999, by = "terms")
vegan::adonis2(unif_dist.ps.bac ~ plot + fgr_sown*psr + leg + gra, data = data.bac1, permutations = 999, by = "terms")

# PERMANOVA fungi
vegan::adonis2(unif_dist.ps.fun ~ plot + psr*fgr_sown + leg + gra, data = data.fun1, permutations = 999, by = "terms")
vegan::adonis2(unif_dist.ps.fun ~ plot + fgr_sown*psr + leg + gra, data = data.fun1, permutations = 999, by = "terms")
```

**2.3 Calculate %Sum of Squares, and create summary table**

Our goal is to create a table with all F and *p*-values, already modified to show 3 digits after comma, along with the %SS. As we have many models, we write a function to simplify the process, which calculates the %SS, rounds our F, *p*, and %SS values to be uniform, and binds all them together based on domain of life for easier export.

Write the function:

```{r functionSS, tidy=TRUE, message=FALSE, warning=FALSE, results='hide'}
get_permanova_stats <- function(adonis_obj) {
  aov_tab <- adonis_obj
  # Extract SS including residuals for %SS
  total_SS <- sum(aov_tab$SumOfSqs, na.rm = TRUE)
  # Remove residuals for table display
  aov_tab <- aov_tab[!rownames(aov_tab) %in% c("Residual", "Total"), ]
  Fval <- aov_tab$F
  pval <- aov_tab$`Pr(>F)`
  perc_SS <- round((aov_tab$SumOfSqs / total_SS) * 100, 3)
  data.frame(
    Term = rownames(aov_tab),
    F_value = round(Fval, 3),
    p_value = round(pval, 3),
    Percent_SS = perc_SS,
    row.names = NULL
  )
}
```

Now we apply the function to our models:

```{r functionUSE, tidy=TRUE, message=FALSE, warning=FALSE}
## Define PERMANOVA output as objects 
perm.B1 = vegan::adonis2(unif_dist.ps.bac ~ plot + psr*fgr_sown + leg + gra, data = data.bac1, permutations = 999, by = "terms")

perm.B2 = vegan::adonis2(unif_dist.ps.bac ~ plot + fgr_sown*psr + leg + gra, data = data.bac1, permutations = 999, by = "terms")

perm.F1 = vegan::adonis2(unif_dist.ps.fun ~ plot + psr*fgr_sown + leg + gra, data = data.fun1, permutations = 999, by = "terms")

perm.F2 = vegan::adonis2(unif_dist.ps.fun ~ plot + fgr_sown*psr + leg + gra, data = data.fun1, permutations = 999, by = "terms")

## Apply function
print(get_permanova_stats(perm.B1))
print(get_permanova_stats(perm.B2))
print(get_permanova_stats(perm.F1))
print(get_permanova_stats(perm.F2))
```
